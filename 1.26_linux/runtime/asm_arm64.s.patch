//--from
TEXT runtime·procyieldAsm(SB),NOSPLIT,$0-0
	MOVWU	cycles+0(FP), R0
	CBZ	 R0, done
	//Prevent speculation of subsequent counter/timer reads and memory accesses.
	ISB     $15
	// If the delay is very short, just return.
	// Hardcode 18ns as the first ISB delay.
	CMP     $18, R0
	BLS     done
	// Adjust for overhead of initial ISB.
	SUB     $18, R0, R0
	// Convert the delay from nanoseconds to counter/timer ticks.
	// Read the counter/timer frequency.
	// delay_ticks = (delay * CNTFRQ_EL0) / 1e9
	// With the below simplifications and adjustments,
	// we are usually within 2% of the correct value:
	// delay_ticks = (delay + delay / 16) * CNTFRQ_EL0 >> 30
	MRS     CNTFRQ_EL0, R1
	ADD     R0>>4, R0, R0
	MUL     R1, R0, R0
	LSR     $30, R0, R0
	CBZ     R0, done
	// start = current counter/timer value
	MRS     CNTVCT_EL0, R2
delay:
	// Delay using ISB for all ticks.
	ISB     $15
	// Substract and compare to handle counter roll-over.
	// counter_read() - start < delay_ticks
	MRS     CNTVCT_EL0, R1
	SUB     R2, R1, R1
	CMP     R0, R1
	BCC     delay
done:
	RET
//--to
TEXT runtime·procyieldAsm(SB),NOSPLIT,$0-0
	MOVWU	cycles+0(FP), R0
	CBZ	R0, done
again:
	YIELD
	SUBW	$1, R0
	CBNZ	R0, again
done:
	RET
